---
title: A new focus on tidygraph
description: >
  A new tidygraph release is out. Read here what's new in v1.3.0
author: Thomas Lin Pedersen
date: '2023-12-18'
slug: a-new-focus-on-tidygraph
large_thumb: yes
img:
  thumb: assets/images/tidygraph_logo.png
categories:
  - R
tags:
  - tidygraph
  - announcement
  - package
---



<p>I’m pleased to announce a new release of <a href="https://tidygraph.data-imaginist.com">tidygraph</a>. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the <a href="https://tidygraph.data-imaginist.com">project website</a> first and become a user.</p>
<div id="let-us-focus-on-the-news" class="section level2">
<h2>Let us focus on the news</h2>
<p>One new feature I’m particularly exited about is the inclusion of a new <code>focus()</code>/<code>unfocus()</code> pair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do?</p>
<p>Let’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine - we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges?</p>
<p>Enter the <code>focus()</code> verb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not.</p>
<pre class="r"><code>library(tidygraph)</code></pre>
<pre><code>## 
## Attaching package: &#39;tidygraph&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     filter</code></pre>
<pre class="r"><code>graph &lt;- play_forestfire(1e5, 0.1) |&gt; 
  mutate(important = dplyr::row_number() &lt;= 5) |&gt; 
  focus(important) |&gt; 
  mutate(efficiency = node_efficiency()) |&gt; 
  unfocus()

graph |&gt; 
  as_tibble() |&gt; 
  slice(1:10)</code></pre>
<pre><code>## # A tibble: 10 × 2
##    important efficiency
##    &lt;lgl&gt;          &lt;dbl&gt;
##  1 TRUE          0.0253
##  2 TRUE          0.0274
##  3 TRUE          0.0417
##  4 TRUE          0.0306
##  5 TRUE          0.0368
##  6 FALSE        NA     
##  7 FALSE        NA     
##  8 FALSE        NA     
##  9 FALSE        NA     
## 10 FALSE        NA</code></pre>
<p>In the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen.</p>
<p>Focus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all.</p>
</div>
<div id="iterating-on-old-ideas" class="section level2">
<h2>Iterating on old ideas</h2>
<p>Another old feature idea of mine that finally materialized is a set of <code>iterate_*()</code> verbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of <code>while () {}</code> and <code>for () {}</code> so you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes:</p>
<pre class="r"><code>unwire &lt;- function(graph) {
  edge &lt;- graph |&gt; 
    activate(nodes) |&gt; 
    mutate(well_connected = centrality_degree() &gt; 1) |&gt; 
    activate(edges) |&gt; 
    mutate(can_remove = .N()$well_connected[from] &amp; .N()$well_connected[to],
           will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |&gt; 
    pull(will_remove)
  graph |&gt; 
    activate(edges) |&gt; 
    filter(!edge)
}</code></pre>
<p>We can use this function 20 times on our graph with the <code>iterate_n()</code> verbs like so:</p>
<pre class="r"><code>create_notable(&#39;meredith&#39;) |&gt; 
  iterate_n(20, unwire)</code></pre>
<pre><code>## # A tbl_graph: 70 nodes and 120 edges
## #
## # An undirected simple graph with 1 component
## #
## # Node Data: 70 × 0 (active)
## #
## # Edge Data: 120 × 2
##    from    to
##   &lt;int&gt; &lt;int&gt;
## 1     1     5
## 2     1     6
## 3     1     7
## # ℹ 117 more rows</code></pre>
<p>Alternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the <code>unwire()</code> function until the graph has been split up into two components.</p>
<pre class="r"><code>create_notable(&#39;meredith&#39;) |&gt; 
  iterate_while(graph_component_count() == 1, unwire) |&gt; 
  ggraph::autograph()</code></pre>
<p><img src="/post/2023-12-18-a-new-focus-on-tidygraph_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
</div>
<div id="catching-up" class="section level2">
<h2>Catching up</h2>
<p>It’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions:</p>
<ul>
<li><p><code>edge_is_bridge()</code> will test for whether edges are bridges (their removal will result in splitting up a component into two</p></li>
<li><p><code>edge_is_feedback_arc()</code> queries whether edges are part of the feedback arc set</p></li>
<li><p><code>graph_is_eulerian()</code> and <code>edge_rank_eulerian()</code> provides access to eulerian path and cycle calculations</p></li>
<li><p><code>graph_efficiency()</code> and <code>node_efficiency()</code> provides access to global and local efficiency calculations</p></li>
<li><p><code>group_leiden()</code> and <code>group_fluid()</code> provides access to the new <code>cluster_leiden()</code> and <code>cluster_fluid_communities()</code> community detection algorithms</p></li>
<li><p><code>group_color()</code> provides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node</p></li>
<li><p><code>centrality_harmonic()</code> supersedes <code>centrality_closeness_harmonic()</code> using an efficient C implementation over the flexible but slower implementation from the netrankr package</p></li>
<li><p><code>random_walk_rank()</code> provides access to random walks on both edges and nodes</p></li>
<li><p><code>to_largest_component()</code> and <code>to_random_spanning_tree()</code> are two new morphers</p></li>
<li><p><code>node_is_connected()</code> tests whether nodes are connected to all or any of the nodes in a given set</p></li>
</ul>
<p>Apart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various <code>slice_*()</code> types so that you can now use e.g. <code>slice_min()</code> or <code>slice_sample()</code> on tbl_graph objects. And while not directly dplyr (but tidyr) you can now use <code>replace_na()</code> and <code>drop_na()</code> with tbl_graph objects as well.</p>
</div>
<div id="wrapping-up" class="section level2">
<h2>Wrapping up</h2>
<p>Mature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care</p>
</div>
